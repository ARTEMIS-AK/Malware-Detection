# Malware-Detection

## Malware Detection Project

This project explores the analysis and classification of malware using a dataset of 138,047 samples, consisting of 41,323 legitimate binaries (exe, dll) and 96,724 malware files from virusshare.com. The objective is to build models that can effectively distinguish between legitimate and malware files based on various features extracted from the binaries.

### Dataset Overview

The dataset contains 57 features for each sample, including properties such as `Machine`, `SizeOfOptionalHeader`, `Characteristics`, and various entropy measures related to resources. The features represent different aspects of the binary files that can be used to identify patterns distinguishing malware from legitimate files.

### Data Loading and Exploration

The data is loaded using pandas, and a brief exploration is conducted to understand its structure:

```python
malData = pd.read_csv("/content/MalwareData.csv", sep="|", low_memory=True)
print(malData.shape)
malData.head()
```

### Data Splitting

The dataset is split into two parts: `legit` for legitimate files and `mal` for malware files. This separation helps in analyzing the two classes independently:

```python
legit = malData[0:41323].drop(["legitimate"], axis=1)
mal = malData[41323::].drop(["legitimate"], axis=1)
print("The shape of the legit dataset is:", legit.shape)
print("The shape of the mal dataset is:", mal.shape)
```

### Data Cleaning

Unnecessary columns like `Name` and `md5` are removed to focus on relevant features:

```python
y = malData['legitimate']
malData = malData.drop(['legitimate', 'Name', 'md5'], axis=1)
```

### Model Building

Three models are built and evaluated: Random Forest, Logistic Regression, and a Neural Network.

#### 1. Random Forest

A Random Forest classifier is trained and evaluated on the dataset. It achieves high accuracy on both training and test datasets:

```python
from sklearn.ensemble import RandomForestClassifier

clf = RandomForestClassifier(max_depth=2, random_state=0)
randomModel = clf.fit(X_train, y_train)
print("Train Accuracy:", accuracy_score(y_train, randomModel.predict(X_train)))
print("Test Accuracy:", accuracy_score(y_test, randomModel.predict(X_test)))
print("F1 Score:", f1_score(y_test, randomModel.predict(X_test)))
```


#### 2. Logistic Regression

A Logistic Regression model is built, but it struggles to converge, resulting in lower accuracy:

```python
from sklearn.linear_model import LogisticRegression

clf = LogisticRegression(random_state=0)
logModel = clf.fit(X_train, y_train)
print("Train Accuracy:", accuracy_score(y_train, logModel.predict(X_train)))
print("Test Accuracy:", accuracy_score(y_test, logModel.predict(X_test)))
print("F1 Score:", f1_score(y_test, logModel.predict(X_test)))
```

#### 3. Neural Network

A simple Neural Network is designed using TensorFlow and Keras. It demonstrates significant improvement over Logistic Regression and achieves high accuracy:

```python
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

model = Sequential()
model.add(Dense(16, input_dim=54, activation="relu"))
model.add(Dense(8, activation="relu"))
model.add(Dense(4, activation="relu"))
model.add(Dense(1, activation='sigmoid'))

model.compile(loss="binary_crossentropy", optimizer="rmsprop", metrics=["accuracy"])
model.fit(X_train, y_train, epochs=5, batch_size=32)

print("Train Accuracy:", accuracy_score(y_train, [1 if y >= 0.5 else 0 for y in model.predict(X_train)]))
print("Test Accuracy:", accuracy_score(y_test, [1 if y >= 0.5 else 0 for y in model.predict(X_test)]))
print("F1 Score:", f1_score(y_test, [1 if y >= 0.5 else 0 for y in model.predict(X_test)]))
```

### Summary

The project successfully demonstrates the use of machine learning models for malware detection. The Random Forest model achieved the highest accuracy, followed by the Neural Network. Logistic Regression, while simpler, was less effective due to convergence issues. Further tuning and more complex models could be explored to improve the detection capabilities.

The code and data used in this project are available in this repository. Feel free to explore and extend the analysis.
